{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\VICKY MISHRA\\\\Desktop\\\\Takcart-shopping-app\\\\tacart\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar utils = require('@motionone/utils');\nvar inset = require('./inset.cjs.js');\nvar presets = require('./presets.cjs.js');\nvar offset = require('./offset.cjs.js');\nvar point = {\n  x: 0,\n  y: 0\n};\nfunction resolveOffsets(container, info, options) {\n  var _options$offset = options.offset,\n    offsetDefinition = _options$offset === void 0 ? presets.ScrollOffset.All : _options$offset;\n  var _options$target = options.target,\n    target = _options$target === void 0 ? container : _options$target,\n    _options$axis = options.axis,\n    axis = _options$axis === void 0 ? \"y\" : _options$axis;\n  var lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  var inset$1 = target !== container ? inset.calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  var targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  var containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  var hasChanged = !info[axis].interpolate;\n  var numOffsets = offsetDefinition.length;\n  for (var i = 0; i < numOffsets; i++) {\n    var offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n    if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset$1;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = _toConsumableArray(info[axis].offset);\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nexports.resolveOffsets = resolveOffsets;","map":null,"metadata":{},"sourceType":"script"}