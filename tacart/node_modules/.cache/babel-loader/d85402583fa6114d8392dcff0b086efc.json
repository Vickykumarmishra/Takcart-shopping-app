{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\VICKY MISHRA\\\\Desktop\\\\Takcart-shopping-app\\\\tacart\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\VICKY MISHRA\\\\Desktop\\\\Takcart-shopping-app\\\\tacart\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nvar observers = new WeakMap();\nvar fireObserverCallback = function fireObserverCallback(entry) {\n  var callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nvar fireAllObserverCallbacks = function fireAllObserverCallbacks(entries) {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_ref) {\n  var root = _ref.root,\n    options = _objectWithoutProperties(_ref, [\"root\"]);\n  var lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  var rootObservers = observers.get(lookupRoot);\n  var key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, _objectSpread({\n      root: root\n    }, options));\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  var rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return function () {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\nexport { observeIntersection };","map":null,"metadata":{},"sourceType":"module"}