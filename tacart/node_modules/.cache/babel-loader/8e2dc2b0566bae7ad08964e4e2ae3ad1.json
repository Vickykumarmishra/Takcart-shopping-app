{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\nfunction useViewport(_ref) {\n  var visualElement = _ref.visualElement,\n    whileInView = _ref.whileInView,\n    onViewportEnter = _ref.onViewportEnter,\n    onViewportLeave = _ref.onViewportLeave,\n    _ref$viewport = _ref.viewport,\n    viewport = _ref$viewport === void 0 ? {} : _ref$viewport;\n  var state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _ref2) {\n  var root = _ref2.root,\n    rootMargin = _ref2.margin,\n    _ref2$amount = _ref2.amount,\n    amount = _ref2$amount === void 0 ? \"some\" : _ref2$amount,\n    once = _ref2.once;\n  useEffect(function () {\n    if (!shouldObserve || !visualElement.current) return;\n    var options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin: rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    var intersectionCallback = function intersectionCallback(entry) {\n      var isIntersecting = entry.isIntersecting;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      var props = visualElement.getProps();\n      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _ref3) {\n  var _ref3$fallback = _ref3.fallback,\n    fallback = _ref3$fallback === void 0 ? true : _ref3$fallback;\n  useEffect(function () {\n    if (!shouldObserve || !fallback) return;\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\n     * Fire this in an rAF because, at this point, the animation state\n     * won't have flushed for the first time and there's certain logic in\n     * there that behaves differently on the initial animation.\n     *\n     * This hook should be quite rarely called so setting this in an rAF\n     * is preferred to changing the behaviour of the animation state.\n     */\n    requestAnimationFrame(function () {\n      state.hasEnteredView = true;\n      var _visualElement$getPro = visualElement.getProps(),\n        onViewportEnter = _visualElement$getPro.onViewportEnter;\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\nexport { useViewport };","map":null,"metadata":{},"sourceType":"module"}