{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\VICKY MISHRA\\\\Desktop\\\\Takcart-shopping-app\\\\tacart\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\VICKY MISHRA\\\\Desktop\\\\Takcart-shopping-app\\\\tacart\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport { keyframes } from './keyframes.mjs';\nimport { spring } from './spring.mjs';\nimport { decay } from './decay.mjs';\nimport { sync, cancelSync } from '../../frameloop/index.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nvar types = {\n  decay: decay,\n  keyframes: keyframes,\n  tween: keyframes,\n  spring: spring\n};\nfunction loopElapsed(elapsed, duration) {\n  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed) {\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var isForwardPlayback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nvar framesync = function framesync(update) {\n  var passTimestamp = function passTimestamp(_ref) {\n    var delta = _ref.delta;\n    return update(delta);\n  };\n  return {\n    start: function start() {\n      return sync.update(passTimestamp, true);\n    },\n    stop: function stop() {\n      return cancelSync.update(passTimestamp);\n    }\n  };\n};\nfunction animate(_ref2) {\n  var duration = _ref2.duration,\n    _ref2$driver = _ref2.driver,\n    driver = _ref2$driver === void 0 ? framesync : _ref2$driver,\n    _ref2$elapsed = _ref2.elapsed,\n    elapsed = _ref2$elapsed === void 0 ? 0 : _ref2$elapsed,\n    _ref2$repeat = _ref2.repeat,\n    repeatMax = _ref2$repeat === void 0 ? 0 : _ref2$repeat,\n    _ref2$repeatType = _ref2.repeatType,\n    repeatType = _ref2$repeatType === void 0 ? \"loop\" : _ref2$repeatType,\n    _ref2$repeatDelay = _ref2.repeatDelay,\n    repeatDelay = _ref2$repeatDelay === void 0 ? 0 : _ref2$repeatDelay,\n    keyframes$1 = _ref2.keyframes,\n    _ref2$autoplay = _ref2.autoplay,\n    autoplay = _ref2$autoplay === void 0 ? true : _ref2$autoplay,\n    onPlay = _ref2.onPlay,\n    onStop = _ref2.onStop,\n    onComplete = _ref2.onComplete,\n    onRepeat = _ref2.onRepeat,\n    onUpdate = _ref2.onUpdate,\n    _ref2$type = _ref2.type,\n    type = _ref2$type === void 0 ? \"keyframes\" : _ref2$type,\n    options = _objectWithoutProperties(_ref2, [\"duration\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"keyframes\", \"autoplay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\", \"type\"]);\n  var _a, _b;\n  var initialElapsed = elapsed;\n  var driverControls;\n  var repeatCount = 0;\n  var computedDuration = duration;\n  var isComplete = false;\n  var isForwardPlayback = true;\n  var interpolateFromNumber;\n  var animator = types[keyframes$1.length > 2 ? \"keyframes\" : type] || keyframes;\n  var origin = keyframes$1[0];\n  var target = keyframes$1[keyframes$1.length - 1];\n  var state = {\n    done: false,\n    value: origin\n  };\n  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {\n    interpolateFromNumber = interpolate([0, 100], [origin, target], {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  var animation = animator(_objectSpread({}, options, {\n    duration: duration,\n    keyframes: keyframes$1\n  }));\n  function repeat() {\n    repeatCount++;\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n  function complete() {\n    driverControls && driverControls.stop();\n    onComplete && onComplete();\n  }\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n    if (!isComplete) {\n      state = animation.next(Math.max(0, elapsed));\n      if (interpolateFromNumber) state.value = interpolateFromNumber(state.value);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n    onUpdate && onUpdate(state.value);\n    if (isComplete) {\n      if (repeatCount === 0) {\n        computedDuration = computedDuration !== undefined ? computedDuration : elapsed;\n      }\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n  function play() {\n    onPlay && onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n  autoplay && play();\n  return {\n    stop: function stop() {\n      onStop && onStop();\n      driverControls && driverControls.stop();\n    },\n    /**\n     * Set the current time of the animation. This is purposefully\n     * mirroring the WAAPI animation API to make them interchanagable.\n     * Going forward this file should be ported more towards\n     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts\n     * Which behaviourally adheres to WAAPI as far as possible.\n     *\n     * WARNING: This is not safe to use for most animations. We currently\n     * only use it for handoff from WAAPI within Framer.\n     *\n     * This animation function consumes time every frame rather than being sampled for time.\n     * So the sample() method performs some headless frames to ensure\n     * repeats are handled correctly. Ideally in the future we will replace\n     * that method with this, once repeat calculations are pure.\n     */\n    set currentTime(t) {\n      elapsed = initialElapsed;\n      update(t);\n    },\n    /**\n     * animate() can't yet be sampled for time, instead it\n     * consumes time. So to sample it we have to run a low\n     * temporal-resolution version.\n     */\n    sample: function sample(t) {\n      elapsed = initialElapsed;\n      var sampleResolution = duration && typeof duration === \"number\" ? Math.max(duration * 0.5, 50) : 50;\n      var sampleElapsed = 0;\n      update(0);\n      while (sampleElapsed <= t) {\n        var remaining = t - sampleElapsed;\n        update(Math.min(remaining, sampleResolution));\n        sampleElapsed += sampleResolution;\n      }\n      return state;\n    }\n  };\n}\nexport { animate, hasRepeatDelayElapsed, loopElapsed, reverseElapsed };","map":null,"metadata":{},"sourceType":"module"}