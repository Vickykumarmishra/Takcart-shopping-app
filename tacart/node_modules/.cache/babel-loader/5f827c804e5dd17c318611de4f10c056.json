{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar heyListen = require('hey-listen');\nvar animateStyle = require('./animate-style.cjs.js');\nvar options = require('./utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar controls = require('./utils/controls.cjs.js');\nvar stagger = require('../utils/stagger.cjs.js');\nfunction createAnimate(AnimatePolyfill) {\n  return function animate(elements, keyframes) {\n    var options$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    elements = resolveElements.resolveElements(elements);\n    var numElements = elements.length;\n    heyListen.invariant(Boolean(numElements), \"No valid element provided.\");\n    heyListen.invariant(Boolean(keyframes), \"No keyframes defined.\");\n    /**\n     * Create and start new animations\n     */\n    var animationFactories = [];\n    for (var i = 0; i < numElements; i++) {\n      var element = elements[i];\n      for (var key in keyframes) {\n        var valueOptions = options.getOptions(options$1, key);\n        valueOptions.delay = stagger.resolveOption(valueOptions.delay, i, numElements);\n        var animation = animateStyle.animateStyle(element, key, keyframes[key], valueOptions, AnimatePolyfill);\n        animationFactories.push(animation);\n      }\n    }\n    return controls.withControls(animationFactories, options$1,\n    /**\n     * TODO:\n     * If easing is set to spring or glide, duration will be dynamically\n     * generated. Ideally we would dynamically generate this from\n     * animation.effect.getComputedTiming().duration but this isn't\n     * supported in iOS13 or our number polyfill. Perhaps it's possible\n     * to Proxy animations returned from animateStyle that has duration\n     * as a getter.\n     */\n    options$1.duration);\n  };\n}\nexports.createAnimate = createAnimate;","map":null,"metadata":{},"sourceType":"script"}