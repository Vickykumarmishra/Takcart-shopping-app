{"ast":null,"code":"import { time } from '@motionone/utils';\nimport { defaults } from './defaults.es.js';\nimport { calcDampingRatio } from './utils.es.js';\nimport { hasReachedTarget } from '../utils/has-reached-target.es.js';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\nvar spring = function spring() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    _ref$stiffness = _ref.stiffness,\n    stiffness = _ref$stiffness === void 0 ? defaults.stiffness : _ref$stiffness,\n    _ref$damping = _ref.damping,\n    damping = _ref$damping === void 0 ? defaults.damping : _ref$damping,\n    _ref$mass = _ref.mass,\n    mass = _ref$mass === void 0 ? defaults.mass : _ref$mass,\n    _ref$from = _ref.from,\n    from = _ref$from === void 0 ? 0 : _ref$from,\n    _ref$to = _ref.to,\n    to = _ref$to === void 0 ? 1 : _ref$to,\n    _ref$velocity = _ref.velocity,\n    velocity = _ref$velocity === void 0 ? 0.0 : _ref$velocity,\n    _ref$restSpeed = _ref.restSpeed,\n    restSpeed = _ref$restSpeed === void 0 ? 2 : _ref$restSpeed,\n    _ref$restDistance = _ref.restDistance,\n    restDistance = _ref$restDistance === void 0 ? 0.5 : _ref$restDistance;\n  velocity = velocity ? time.s(velocity) : 0.0;\n  var state = {\n    done: false,\n    hasReachedTarget: false,\n    current: from,\n    target: to\n  };\n  var initialDelta = to - from;\n  var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n  var dampingRatio = calcDampingRatio(stiffness, damping, mass);\n  var resolveSpring;\n  if (dampingRatio < 1) {\n    var angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n    // Underdamped spring (bouncy)\n    resolveSpring = function resolveSpring(t) {\n      return to - Math.exp(-dampingRatio * undampedAngularFreq * t) * ((-velocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else {\n    // Critically damped spring\n    resolveSpring = function resolveSpring(t) {\n      return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t);\n    };\n  }\n  return function (t) {\n    state.current = resolveSpring(t);\n    var currentVelocity = t === 0 ? velocity : calcGeneratorVelocity(resolveSpring, t, state.current);\n    var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n    var isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;\n    state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n    state.hasReachedTarget = hasReachedTarget(from, to, state.current);\n    return state;\n  };\n};\nexport { spring };","map":null,"metadata":{},"sourceType":"module"}